# bot.py (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø 3)
import logging
import os
import json
from collections import defaultdict

import httpx
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.constants import ParseMode, ChatAction
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler

# –ö–∞—Å—Ç–æ–º–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã
from models import MODELS, DEFAULT_MODEL

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env —Ñ–∞–π–ª–∞
load_dotenv()

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ---
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
YOUR_SITE_URL = "https://t.me/your_bot_username" # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Å–≤–æ–µ –∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ
YOUR_SITE_NAME = "My Telegram AI Bot"

logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–π –ø–∞–º—è—Ç–∏
user_data = defaultdict(lambda: {
    "history": [],
    "context_enabled": True,
    "model": DEFAULT_MODEL
})


# --- API –§—É–Ω–∫—Ü–∏—è ---

async def call_openrouter_api(model: str, messages: list) -> dict:
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –≤—ã–∑—ã–≤–∞–µ—Ç OpenRouter API —Å –ø–æ–º–æ—â—å—é httpx."""
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                url="https://openrouter.ai/api/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                    "Content-Type": "application/json",
                    "HTTP-Referer": YOUR_SITE_URL,
                    "X-Title": YOUR_SITE_NAME,
                },
                json={"model": model, "messages": messages},
                timeout=120,
            )
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP Error: {e.response.status_code} - {e.response.text}")
            try:
                error_details = e.response.json().get("error", {}).get("message", e.response.text)
            except json.JSONDecodeError:
                error_details = e.response.text
            return {"error": f"–û—à–∏–±–∫–∞ API: {e.response.status_code}. {error_details}"}
        except Exception as e:
            logger.error(f"An unexpected error occurred: {e}")
            return {"error": f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}"}


# --- –§—É–Ω–∫—Ü–∏–∏ –ö–ª–∞–≤–∏–∞—Ç—É—Ä ---

def get_main_keyboard(user_id: int) -> ReplyKeyboardMarkup:
    context_status = "–ö–æ–Ω—Ç–µ–∫—Å—Ç: ‚úÖ –í–ö–õ" if user_data[user_id]["context_enabled"] else "–ö–æ–Ω—Ç–µ–∫—Å—Ç: ‚ùå –í–´–ö–õ"
    keyboard = [["/models", "/reset"], [context_status]]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)

def get_models_keyboard() -> InlineKeyboardMarkup:
    keyboard = []
    for model_id, details in MODELS.items():
        button_text = f"üì∏ {details['name']}" if details['vision'] else details['name']
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"model:{model_id}")])
    return InlineKeyboardMarkup(keyboard)

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ö–æ–º–∞–Ω–¥ ---

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user, user_id = update.effective_user, update.effective_user.id
    user_data[user_id] = {
        "history": [], 
        "context_enabled": True, 
        "model": DEFAULT_MODEL
    }
    logger.info(f"User {user.username} (ID: {user_id}) started the bot.")
    await update.message.reply_html(
        rf"–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! –Ø AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ "
        "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–¥–ø–∏—Å—å—é, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.\n\n"
        "üì∏ - –º–æ–¥–µ–ª–∏, —Ä–∞–±–æ—Ç–∞—é—â–∏–µ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏.",
        reply_markup=get_main_keyboard(user_id)
    )
    await models_command(update, context)

async def reset_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    user_data[user_id]["history"] = []
    logger.info(f"History reset for user ID: {user_id}")
    await update.message.reply_text("–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–∞ —Å–±—Ä–æ—à–µ–Ω–∞.", reply_markup=get_main_keyboard(user_id))

async def models_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    current_model_id = user_data[user_id].get('model', DEFAULT_MODEL)
    current_model_name = MODELS.get(current_model_id, {}).get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è')
    await update.message.reply_text(
        f"–¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å: `{current_model_name}`\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—É—é –º–æ–¥–µ–ª—å:",
        reply_markup=get_models_keyboard(),
        parse_mode=ParseMode.MARKDOWN
    )

async def toggle_context_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    user_data[user_id]["context_enabled"] = not user_data[user_id]["context_enabled"]
    state = "–≤–∫–ª—é—á–µ–Ω" if user_data[user_id]["context_enabled"] else "–≤—ã–∫–ª—é—á–µ–Ω"
    logger.info(f"Context toggled to {state} for user ID: {user_id}")
    await update.message.reply_text(f"–†–µ–∂–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ {state}.", reply_markup=get_main_keyboard(user_id))


# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –°–æ–æ–±—â–µ–Ω–∏–π ---

async def model_button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    # --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï ‚Ññ1: –†–∞–∑–±–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫—É —Ç–æ–ª—å–∫–æ –ø–æ –ø–µ—Ä–≤–æ–º—É ':' ---
    model_id = query.data.split(":", 1)[1]
    
    user_data[user_id]["model"] = model_id
    model_name = MODELS.get(model_id, {}).get('name', "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è")
    
    logger.info(f"User ID {user_id} switched model to: {model_id}")
    await query.edit_message_text(text=f"‚úÖ –ú–æ–¥–µ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: `{model_name}`", parse_mode=ParseMode.MARKDOWN)

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_input = update.message.text
    
    if user_input == "/reset": return await reset_command(update, context)
    if user_input == "/models": return await models_command(update, context)
    if user_input.startswith("–ö–æ–Ω—Ç–µ–∫—Å—Ç:"): return await toggle_context_command(update, context)

    # --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï ‚Ññ2: –£–±—Ä–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞, –±–ª–æ–∫–∏—Ä—É—é—â–∞—è —Ç–µ–∫—Å—Ç –¥–ª—è vision-–º–æ–¥–µ–ª–µ–π ---
    # –¢–µ–ø–µ—Ä—å –ª—é–±–æ–π —Ç–µ–∫—Å—Ç –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ –ª—é–±—É—é –º–æ–¥–µ–ª—å
    await process_request(update, context, user_input)

async def handle_photo_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    current_model_id = user_data[user_id]['model']

    if not MODELS[current_model_id]['vision']:
        await update.message.reply_text(
            f"–¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å `{MODELS[current_model_id]['name']}` –Ω–µ —É–º–µ–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏. "
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ '–∑—Ä—è—á—É—é' –º–æ–¥–µ–ª—å (—Å üì∏) —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /models."
        )
        return

    photo_file = await update.message.photo[-1].get_file()
    image_url = photo_file.file_path
    
    text_prompt = update.message.caption or "–ß—Ç–æ –Ω–∞ —ç—Ç–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏?"

    vision_payload = [
        {"type": "text", "text": text_prompt},
        {"type": "image_url", "image_url": {"url": image_url}}
    ]
    await process_request(update, context, text_prompt, vision_payload)

async def process_request(update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str, vision_payload: list = None) -> None:
    user_id = update.effective_user.id
    await context.bot.send_chat_action(chat_id=user_id, action=ChatAction.TYPING)

    messages_for_api = []
    if user_data[user_id]["context_enabled"]:
        messages_for_api.extend(user_data[user_id]["history"])

    if vision_payload:
        messages_for_api.append({"role": "user", "content": vision_payload})
    else:
        messages_for_api.append({"role": "user", "content": user_input})
    
    api_response = await call_openrouter_api(user_data[user_id]["model"], messages_for_api)

    if "error" in api_response:
        bot_response_text = api_response["error"]
    else:
        bot_response_text = api_response.get('choices', [{}])[0].get('message', {}).get('content', '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç –º–æ–¥–µ–ª–∏.')

    if user_data[user_id]["context_enabled"] and "error" not in api_response:
        user_data[user_id]["history"].append({"role": "user", "content": user_input})
        user_data[user_id]["history"].append({"role": "assistant", "content": bot_response_text})

    await update.message.reply_text(bot_response_text, reply_markup=get_main_keyboard(user_id))

# --- –û—Å–Ω–æ–≤–Ω–∞—è –§—É–Ω–∫—Ü–∏—è ---

def main() -> None:
    if not TELEGRAM_TOKEN or not OPENROUTER_API_KEY:
        logger.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: TELEGRAM_TOKEN –∏–ª–∏ OPENROUTER_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ .env —Ñ–∞–π–ª–µ!")
        return

    application = Application.builder().token(TELEGRAM_TOKEN).build()

    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("reset", reset_command))
    application.add_handler(CommandHandler("models", models_command))
    application.add_handler(CallbackQueryHandler(model_button_callback, pattern="^model:"))
    
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))
    application.add_handler(MessageHandler(filters.PHOTO, handle_photo_message))

    logger.info("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    application.run_polling()

if __name__ == "__main__":
    main()
